# 그래프 이론

> 처음으로 개념 끝까지 도달했다. 확실히 스터디를 하니 강제성이 생기고 열심히 따라가게 된다. 이번 장도 열심히 이해해보도록 하자.

이전에 다룬 dfs,bfs와 최단경로 둘다 그래프 알고리즘의 한 유형으로 볼 수 있다. 출제 비중은 낮은 편이지만 꼭 제대로 알아야 하는 알고리즘이다.

이번 장에서 다룰 내용은 앞서 배운 내용에 기반하는데, 예를들어 크루스칼 알고리즘은 그리디 알고리즘으로 분류되며, 위상 정렬 알고리즘은 큐 자료구조 혹은 스택 자료구조를 활용해야 구현할 수 있다. 따라서 배운 내용을 잘 이해하고 있다면 크게 어렵지 않다.

먼저 `그래프란 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조`를 의미한다. 알고리즘 문제를 접했을 때 서로 다른 개체가 연결되어 있다는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다. 예를 들어 '여러 개의 도시가 연결되어 있다.' 와 같은 내용이 등장하면 그래프 알고리즘을 의심해보자.

더불어 그래프 자료구조 중에서 트리 자료구조는 다양한 알고리즘에서 사용되므로 꼭 기억하자. 최소 힙은 항상 부모 노드가 자식 노드보다 크기가 작은 자료구조로서 트리 자료구조에 속한다. 트리 자료구조는 부모에서 자식으로 내려오는 계층적인 모델에 속한다. 그래프와 트리 자료구조를, 트리는 전통적인 수학에서는 무방향 그래프로 간주되지만, 컴퓨터 공학에서는 보통 방향 그래프라고 간주된다.

|                     | 그래프                         | 트리             |
| ------------------- | ------------------------------ | ---------------- |
| 방향성              | 방향 그래프 혹은 무방향 그래프 | 방향 그래프      |
| 순환성              | 순환 및 비순환                 | 비순환           |
| 루트 노드 존재 여부 | 루트 노드가 없음               | 루트 노드가 존재 |
| 노드간 관계성       | 부모와 자식 관계 없음          | 부모와 자식 관계 |
| 모델의 종류         | 네트워크 모델                  | 계층 모델        |

그래프의 구현 방법은 2가지 방식이 존재한다.

- 인접행렬 : 2차원 배열을 사용하는 방식
- 인접 리스트 : 리스트를 사용하는 방식

2가지 모두 그래프 알고리즘에서 매우 많이 사용된다. 두 방식은 메모리와 속도 측면에서 구별되는 특징을 가진다. 노드의 갯수가 V, 간선의 갯수가 E인 그래프에서 인접 행렬을 이용하면 O(V^2) 만큼의 메모리가 필요하다. 반면 인접 리스트는 O(E) 만큼의 메모리가 필요하다. 또한 인접 행렬은 특정한 노드 A에서 다른 특정한 노드 B로 이어진 간선의 비용을 O(1)의 시간으로 즉시 알 수 있다는 장점이 있으며, 반면에 인접 리스트를 이용할 때는 O(V) 만큼의 시간이 소요된다.

다익스트라는 인접 리스트를 이용하는 방식이고 플로이드 워셜은 인접 행렬을 이용하는 방식이다. 모든 노드에 대하여 다른 노드로 가는 최소 비용을 V^2 크기의 2차원 리스트에 저장한 뒤 해당 비용을 갱신해서 최단 거리를 계산했다.

알아두어야 할 점은 메모리와 시간을 염두에 두고 알고리즘을 선택해야 한다는 것이다.

## 서로소 집합

수학에서 서로소 집합은 공통 원소가 없는 두 집합을 의미한다. 예를 들어 집합 {1,2}와 집합 {3,4}는 서로소 관계이다. 서로소 집합 자료구조란 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조이다. union과 find 이 2개의 연산으로 조작할 수 있다.

union 연산은 2개의 우너소가 포함된 집합을 하나의 집합으로 합치는 연산이다. find 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다. 스택과 큐가 push 와 pop 연산으로 이루어졌던 것처럼, 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성된다.

서로소 집합 자료구조는 union-find 자료구조라고 불리기도 한다. 연산의 이름 자체가 합치기와 찾기이기도 하고, 두 집합이 서로소 관계인지를 확인할 수 있다는 말은 각 집합이 어떤 원소를 공통으로 가지고 있는지를 확인할 수 있다.

## 신장트리

신장트리란 하나의 그래프가 있을 때, 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다. 이때 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립 조건이기도 하다.

### 크루스칼 알고리즘

우리는 다양한 문제 상황에서 가능한 한 최소한의 비용으로 신장 트리를 찾아야 할 때가 있다. 예를들어 2개의 경로가 있을 때 최소로 가야하는 경우이다. 이처럼 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘을 최소 신장 트리 알고리즘이라고 부르고 대표적으로 크루스칼 알고리즘이 있다.

크루스칼 알고리즘을 이용하면 가장 적은 비용으로 모든 노드를 연결할 수 있는데 크루스칼 알고리즘은 그리디 알고리즘으로 분류된다. 먼저 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시키면 된다. 이때 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다.

크루스칼 알고리즘은 간선의 갯수가 E일 때 O(ElogE)의 시간 복잡도를 가진다.

## 위상정렬

위상 정렬은 정렬 알고리즘의 일종이다. 위상 정렬은 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다. 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것이다.

현실 세계에서 위상정렬을 수행하는 전형적인 예시는 `선수과목을 고려한 학습순서 결정`이다.

1. 진입 차수가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때까지 다음의 과정을 반복한다.
   1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다
   2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

위상 정렬의 시간 복잡도는 O(V+E)이다. 위상 정렬을 수행할 때는 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거해야 한다.